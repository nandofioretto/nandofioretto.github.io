# -*- coding: utf-8 -*-
"""smlprjargmin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZM2DDPF-4d_qUu9NfW16mE93qde6e1l0
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy  # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import io
# Models:
from sklearn import svm
from sklearn.model_selection import cross_validate
from sklearn.linear_model import LinearRegression
from sklearn.model_selection import KFold, cross_val_score
# Python utilities:
import time
import os
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import roc_auc_score
from sklearn.metrics import roc_curve
import matplotlib.pyplot as plt
import datetime
# %tensorflow_version 2.x
import tensorflow as tf

"""Google Collabrate Import Data"""

from google.colab import drive
drive.mount('/content/gdrive')

"""Google Collabrate files uploading"""

from google.colab import files
uploaded = files.upload()
for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

"""Train data and test data imported and test data listed"""

train_data=pd.read_csv('gdrive/My Drive/GiveMeSomeCredit/cs-training.csv')
test_data=pd.read_csv('gdrive/My Drive/GiveMeSomeCredit/cs-test.csv')
cv = KFold(n_splits=2,random_state=None, shuffle=False)

"""First 6 data information"""

train_data.head()

train_data.shape

"""Get overall information more statistical"""

train_data.describe()

"""The ratio of debt to assets"""

train_data.DebtRatio.describe()

"""How balanced the data set is"""

train_data.SeriousDlqin2yrs.mean()

age_hist = train_data['age'].hist(by=train_data['SeriousDlqin2yrs'], bins=20, layout=(2,1))
age_hist[0].set_xlim((0,100))
age_hist[0].set_title('SeriousDlqin2yrs = 0')
age_hist[1].set_xlim((0,100))
age_hist[1].set_title('SeriousDlqin2yrs = 1')

"""Investigate further to see if these are outliers or not"""

train_data.DebtRatio.quantile([.975])

train_data[train_data['DebtRatio'] > 3489.025][['SeriousDlqin2yrs','MonthlyIncome']].describe()

train_data.groupby('NumberOfTimes90DaysLate').NumberOfTimes90DaysLate.count()

train_data[train_data['NumberOfTimes90DaysLate'] > 95][['SeriousDlqin2yrs',
                                                        'NumberOfTime60-89DaysPastDueNotWorse',
  'NumberOfTime30-59DaysPastDueNotWorse',
  'NumberOfTimes90DaysLate']].describe()

"""Choose specific data and get the arg minumum of them"""

def rmDataAndPutArgmin(train_data, first = 20, second = 40):
    New = []
    argminx = train_data.argmin()
    for val in train_data:
        if ((val == first) | (val == second)):
            New.append(argminx)
        else:
            New.append(val)
            
    return New

"""Training Data"""

trainnew = rmDataAndPutArgmin(train_data.SeriousDlqin2yrs)
train_data.SeriousDlqin2yrs=trainnew

x = train_data.drop(['SeriousDlqin2yrs'], axis=1)
y = trainnew

gbscores=[]
for n in [150, 160, 170, 180, 190, 200, 210]:
    gbscores.append(numpy.mean(cross_val_score(GradientBoostingClassifier(learning_rate=0.1, n_estimators=n, verbose=True, random_state=241),x,y,cv=cv,scoring='roc_auc')))
print(gbscores)
start_time = datetime.datetime.now()
print (numpy.mean(cross_val_score(GradientBoostingClassifier(learning_rate=0.1, n_estimators=300, verbose=True, random_state=241),x,y,cv=cv,scoring='roc_auc')))
print ('Time elapsed:', datetime.datetime.now() - start_time)


"""tried to look at using linear regression to fill in the missing values for MonthlyIncome. After 
    argmin it changed from 0.22 to 0.33 """

not_missing = train_data.dropna()
target = 'MonthlyIncome'
predictors = [c for c in list(not_missing) if c not in [target, 'Unnamed: 0','SeriousDlqin2yrs']]
X_data = not_missing[predictors]
y_data = not_missing[target]
regr = LinearRegression().fit(X_data, y_data)
regr.score(X_data, y_data)

train_data=train_data.fillna(round(train_data.median()))
train_data.loc[train_data.DebtRatio > 1, 'DebtRatio'] = train_data['DebtRatio'].median()



"""Roc curve of gradient boosting classifier"""

plt.figure(figsize=(10, 10))
models=[]
models.append(GradientBoostingClassifier(learning_rate=0.1, n_estimators=300, verbose=True, random_state=241))
for model in models:
    model.fit(x,y)
    testscore=model.predict_proba(x)[:, 1] 
    fpr, tpr, thresholds = roc_curve(y, testscore)
    roc_auc = roc_auc_score(y, testscore)
    md = str(model)
    md = md[:md.find('(')]
    plt.plot(fpr, tpr, label='ROC fold %s (auc = %0.2f)' % (md, roc_auc))
    
plt.plot([0, 1], [0, 1], '--', color=(0.6, 0.6, 0.6))
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="best")
plt.show()